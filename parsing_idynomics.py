
### Parsing IDynoMiCS ###

## IDynoMiCS takes an XML protocol file as the input and then writes plain-text XML as the output
## This script is an exploration of parsing the output XML files to see the data generated by the IDynoMiCs package
## The example I used to explore was called "bacilli.xml", a file for testing purposing found in the protocol folder on the iDynoMiCS-2 Github page.

from pathlib import Path
import re
from tkinter import Image
from lxml import etree as ET
import matplotlib.pyplot as plt
import pandas as pd
from collections import Counter

#Path to the simulation results - produced a "bacilli" folder that contains the XML files from the simulation run
run_dir = Path("/Users/mayaabdalla/idyno_demo/runs/demo1/2025.08.28_14.09.26_764_bacilli")
species_dir = run_dir / "bacilli"

#Match XML files like bacilli_0001.xml, bacilli_0002.xml, etc
xml_files = sorted(species_dir.glob("*.xml"))

#Empty list to append data to
data = []

#Extracting timesteps from filenames using regex matching
    #looking for a pattern in the file
    # r - "raw string literal" in python - tells python not to interpret \ or escape characters = cleaner code
    # _ - the underscore before the number
    # (\d+) - one or more digits (the timestep captured in the group)
    # \.xml$ - the filename ends with .xml
# what is (\d+) in Regex?
    # pattern used to find and extract numbers
    # () - captures a group - stores whatever matches inside the ()
    # \d - stands for any single digit (0-9)
    # + - one of more of the preceding token (\d) to allow #'s > 9

#Function to extract the timesteps and counts from each XML filename, pattern looks for an underscore followed by numbers before the .xml extension
def extract_time(filename):
    match = re.search(r"_(\d+)\.xml$", filename.name) #regex matching
    return int(match.group(1)) if match else None

#Loop through all XML files in the input (bacilli folder) and pase the file into an ElementTree structure
#ET.parse() how the XML gets read
#Takes the XML file and reads the file, thinking of the XML file as a "tree", then we getroot() to get the single root element - the "top level" that everything else lives inside
        #This returns the simulation element as an Element object
for xml_file in xml_files:
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
    except Exception as e:
        print(f"{xml_file} failed to parse")
        continue

    time_step = extract_time(xml_file) #gets the timestep for this file

# Iterates over all agents in the XML file to extract agent properties ("agent" is from IDynoMiCS)
    # ".//agent" --> finds all "elements" anywhere in the tree
    # Each agent represents a cell at a timestep
    for agent in root.findall(".//agent"):
        try:
            #Create a dictionary to hold the extracted agent information by pulling data from the XML
            agent_info = {
                "time": time_step,
                "species": agent.attrib.get("name", "unknown"),
                "x": float(agent.findtext("location/x", default="0")), #XML elements that hold coordinates
                "y": float(agent.findtext("location/y", default="0")),
                "z": float(agent.findtext("location/z", default="0")),
                "radius": float(agent.findtext("radius", default="0")),
                "mass": float(agent.findtext("mass", default="0")),
            }
            data.append(agent_info)
        except Exception as e:
            print(f"{xml_file} error parking agent")


print(f"parsed {len(data)} agents agents across {len(xml_files)} xml files")


#Counts agents per timestep in the data list
    #buildsa list of timesteps from all agents, then "Counter" tallies how many agents exist at each timestep (this is the cell counts)
counts = Counter([d["time"] for d in data])

#Convert counts to a panadas dataframe for plotting
df_counts = pd.DataFrame(sorted(counts.items()), columns=["time", "cellcount"])


#Generate a figure and figure specifications
plt.figure(figsize = (12, 8))
plt.plot(df_counts["time"], df_counts["cellcount"], marker="o")
plt.xlabel("time")
plt.ylabel("cellcount")
plt.grid(True)
plt.tight_layout()
plt.savefig("cell_counts.png")
plt.show()

#Okay so got cell_counts which is bacilli_001.xml, 002, etc. is the code above ^
    #When running the simulation, also produced a second_agents folder that contains:
        #second_agents_00001_00001.pov  second_agents_00001_00001.svg
    #Need POV-RAY --> iDynoMiCS 2.0 called POV-RAY internally (producing these files)
    #It's a vision ray-tracer that generates images from a text-based scene description,
    #creates videos from sequences of still frames created by POV-Ray - not able to really see
    #Svgwriter and POVwriter are both processManagers in the raw protocol XML file (priority 3)


#BELOW is my first attempting at trying to use SVG (CAIRO) and it was not working -- CHATGPT had suggested to switch to Jupyter notebook
#Also figured Jupyter notebook might be better to see SVG each files without having to save them or plot (there's 240 files)
from pathlib import Path
import matplotlib.pyplot as plt
from PIL import Image
import io
import cairosvg
import time
import re
import os
import sys
from contextlib import suppress
from ctypes.util import find_library

#Path to second_agents directory - a folder also produced by the IDynoMiCS simulation
second_agents = Path("/Users/mayaabdalla/idyno_demo/runs/demo1/2025.08.28_14.09.26_764_bacilli/second_agents")

# Sorted POV files
pov_files = sorted(second_agents.glob("*.pov"))

# Sorted SVG files
svg_files = sorted(second_agents.glob("*.svg"))

#Check length of how many files (240 pov, 240 svg (240 xml))
print(len(pov_files), len(svg_files))

#Extract timestep from the SVG filename using regrex matching
def svg_images(svg_path):
    match = re.search(r"_(\d+)_\d+\.svg$", svg_path[0].name)
    return int(match.group(1)) if match else None #If regrex finds a match, return first captured number as int

#Sort SVG files by time based on the timestep extracted by svg_images function
svg_files = sorted(svg_files, key=svg_images)

#Loop through each SVG file one by one
for svg_file in svg_files:
    try:
        print(f"Displaying: {svg_file.name}")
        # Convert SVG to PNG in memory because cant see SVG  (trying to make an animation too)
        png_data = cairosvg.svg2png(url=str(svg_file))

        #Open PNG as a pillow image for further use
        #Wraps the raw bytes (png_data) into a file like object
        #Needed to then read because cannot do raw-bytes - did this approach so we don't save to disk and also a lot of data so its faster
        img = Image.open(io.BytesIO(png_data))

        # Display with matplotlib
        plt.figure(figsize=(8, 8))
        plt.imshow(img)
        plt.axis("off")
        plt.title(svg_file.name)
        plt.tight_layout()
        plt.show()

    except Exception as e:
        print(f"Error rendering {svg_file.name}: {e}")

#This script second part of the script is broken - doesn't work due to cairosvg issues and other reasons so I switched to jupyter notebook to see the files and configure cairosvg



